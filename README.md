# functional_programming
Лабораторная работа №0

  # Задачи:
  
  поверхностное ознакомление с предлагаемыми к использованию технологиями по открытым источникам;
  выбор языка программирования и подбор инструментальных средств (компилятор/интерпретатор, система сборки, системы автоматического форматирования, lint tools, инструменты тестирования, стиль кодирования);
  написание эссе объёмом порядка страницы, в рамках которого необходимо:
  
  
  обосновать свой выбор языка программирования;
  высказать соображения на предмет лабораторной работы номер 4;
  привести планируемые к использованию инструментальные средства и список прочитанных статей / книг / руководств при подготовке эссе;
  
  
  выбор книги, по которой вы будете знакомиться с технологией, текст которой необходимо показать на защите данной лабораторной работы и по которой вы будете готовиться к зачёту;
  защита эссе, при этом возможны общие вопросы о невыбранных технологиях.
  
 # Примечания:
  
  при утверждении используемого языка программирования будет учитываться его популярность у ранее определившихся во избежание "курса по технологии Т";
  
  ограничения: не более 20% на технологию (25% на Erlang+Elixir);
  в случае блестящего обоснования -- ограничения могут быть нарушены;
  
  
  не любой язык программирования может быть утвержден;
  выбор языка программирования влияет на то, кто будет принимать лабораторные работы.
  если ваш язык не может быть утверждён:
  
  вы можете его сменить,
  вы можете подождать в надежде что другие студенты "снизят процент",
  вы можете сделать свою аргументацию безупречной.
  
  
  
  # Варианты языков программирования:
  
  Haskell (хорошая система типов, бесточечный стиль, лень, квадратно/гнездовое программирование)
  Clojure (параллельное программирование, eDSL)
  Erlang/OTP (распределенные системы)
  Common Lisp (eDSL, CLOS, бесконечная гибкость)
  Ocaml
  Agda
  F#
  список открытый, предлагайте ваши варианты
  
  Особое (т.к. стандартный набор лабораторных работ не очень применим):

  Coq (формальное доказательство свойств алгоритмов)

  # Не стоит:

  Rust (низкоуровневая разработка в функциональном стиле, уйдёте в особенности языка, а ФП будет по остаточному принципу);
  Scala, Kotlin (несмотря на отличные возможности с точки зрения ФП и системы типов, лучше выбрать что-то более функционально чистое).
